\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[british]{babel}
\usepackage{authblk}
\usepackage{hyperref}
\usepackage{url}
\usepackage{cleveref}
\usepackage{csquotes}

\usepackage{noweb}
% Needed to relax penalty for breaking code chunks across pages, otherwise 
% there might be a lot of space following a code chunk.
\def\nwendcode{\endtrivlist \endgroup}
\let\nwdocspar=\smallbreak

\usepackage[natbib,style=alphabetic,maxbibnames=99]{biblatex}
\addbibresource{texgen.bib}

\title{texgen: A command for generating file structures for \LaTeX}
\author{Daniel Bosk}
\affil{%
  Department of Information Technology and Society\\
  Mid Sweden University, SE-851\,70 Sundsvall
}
\affil{%
  School of Computer Science and Communication\\
  KTH Royal Institute of Technology, SE-100\,44 Stockholm
}

\begin{document}
\maketitle
\begin{abstract}
  \dots
\end{abstract}
\clearpage
\tableofcontents
\clearpage


\section{Introduction}

When we have an idea for something we would like to quickly get started at 
writing.
The idea of texgen is to quickly generate the file structure needed, similarly 
as dtxgen~\cite{dtxgen}.


\section{Implementation overview}

The texgen utility is implemented as a shell script and has the following 
layout.
<<texgen.sh>>=
#!/bin/sh
<<variables>>
<<functions>>
<<parse command-line arguments>>
<<process command-line arguments>>
<<use templates>>
@

We will use getopt(1) to parse the command-line arguments.
If there are no command-line arguments, we will simply print the usage.
Otherwise we let getopt(1) parse them.
<<parse command-line arguments>>=
if [ $# = 0 ]; then
  echo "$0 ${usage}"
  exit 2
fi
args=$(getopt "${options}" "$@")
set -- $args
@ The last line changes the actual arguments from what is given by the user to 
something homogenized by getopt(1).

The next step is to actually process the arguments.
For each argument we finish processing, we will use [[shift]] to remove them.
Thus the first unprocessed argument will always be in the variable [[1]], and 
there will be no arguments left when we are done.
<<process command-line arguments>>=
while [ $# -gt 0 ]; do
  case "$1" in
    <<arguments handler code>>
    --)
      shift; break;;
    *)
      break;;
  esac
done
@

We need to correctly get the arguments for an argument.
This can be problematic when the argument is a string, e.g.\ the title of the 
document.
Unfortunately, getopt(1) loses the escaping while doing this.
But, fortunately, getopt(1) orders the arguments for us, so we can use that to 
solve the problem with the following function.
<<functions>>=
get_arg() {
  for x in "$@"; do
    <<break if x is the next argument>>
    <<otherwise print x>>
  done
}
@

We know that [[x]] is the next argument if it starts with a [[-]].
Thus we can check for that leading character.
<<break if x is the next argument>>=
if [ "${x}" != "${x#-}" ]; then
  break;
@ This also gives us the following.
<<otherwise print x>>=
else
  echo -n " ${x}"
fi
@

The [[get_arg]] function cannot do the required shifts, to clear the processed 
arguments.
However, since we output exactly those values, we can use wc(1) to count the 
words and thus run shift that many times, e.g.\ [[shift $(echo $var | wc -w)]].


\section{Using the templates}

We will keep the templates in a shared directory.
<<variables>>=
template_dir=${TEXGEN_TEMPLATES:=/usr/local/share/texgen}
@ Thus the command can fetch the needed templates from there.
To use them, we will simply do the following.
<<use templates>>=
<<copy templates into location>>
<<substitute values>>
@ We will return to [[<<substitute values>>]] in \cref{DoingSubstitution}.

\subsection{Controlling which templates to use}

We have several templates and it might not be interesting to use all at the 
same time.
Thus we want to control which templates to use, i.e.\ copy into location.
We want to use the basic TeX-files for a document --- which also has 
corresponding slides (using beamerarticle).
<<variables>>=
files="${files} notes.tex slides.tex"
files="${files} preamble.tex contents.tex"
@

There are also other files that we might want.
First, there is the Makefile.
There are two versions, one for a normal document and one for a study guide.
We will add an option to change from the default of a normal document.
<<variables>>=
options="${options}g"
usage="${usage} [-g]"
makefile="Makefile.slides"
@ Then we change the default if the argument is given.
<<arguments handler code>>=
-g)
  makefile="Makefile.studyguide"
  shift;;
@

Second, there are the standard files part of any repository: general 
\enquote{read me}, information about contributions, license.
If the generated document is part of a larger repository, then these files are 
probably already present in the repository root.
If not, then we want to add them too.
<<variables>>=
options="${options}r"
usage="${usage} [-r]"
repo_files=""
@ By default we do not add them, but we add them if the option is given.
<<arguments handler code>>=
-r)
  repo_files="${repo_files} CONTRIBUTING LICENSE README"
  shift;;
@


\subsection{Copying the templates into location}

Now we only have to copy the selected files, i.e.
<<copy templates into location>>=
<<copy the TeX files>>
<<copy the Makefile>>
<<copy the repo files>>
@

Copying the TeX-files is straight-forward, we simply copy them from the 
template directory.
However, we want to check if the file already exists, we would not want to 
overwrite any existing files --- hence requesting cp(1) to prompt before 
overwriting.
<<variables>>=
CP="cp -i"
@ Thus to copy the files we do as follows.
<<copy the TeX files>>=
for f in ${files}; do
  ${CP} ${template_dir}/${f} .
done
@

There should be only one makefile, but use a for-iteration for generality.
The selected file must be renamed.
<<copy the Makefile>>=
for f in ${makefile}; do
  ${CP} ${template_dir}/${f} Makefile
done
@

Finally, we must copy the repository files.
These are more than one and they must all be renamed.
<<copy the repo files>>=
for f in ${repo_files}; do
  ${CP} ${template_dir}/${f}.template ${f}
done
@


\section{Substituting values}
\label{SubstitutingValues}

We want to change some values automatically when we use the templates, this 
will be faster than to do it by hand every time.

\subsection{Doing the substitution}
\label{DoingSubstitution}

Now that we have copied the files, we want to prepare them for use.
In all files we have copied, we want to substitute the place-holders with the 
desired value set above.
What we need to do is to iterate through the list of files and substitute the 
values.
<<substitute values>>=
for f in ${files} Makefile ${repo_files}; do
  <<run sed(1) on file>>
done
@ Now the question is what values to substitute.

There are some values that we can substitute automatically, e.g.\ dates.
We will substitute [[<year>]] with the current year.
<<run sed(1) on file>>=
sed -i "s/<year>/$(date +%Y)/g" ${f}
@

\subsection{Getting the values to substitute}
\label{GettingValues}

Now we will cover those values that we cannot substitute automatically, e.g.\ 
the author's name etc.

The first substitution that comes to mind is to set the author's name and email
address.
We take the default values from the environment variables [[NAME]] and [[MAIL]]
(same as for dtxgen~\cite{dtxgen}).
<<variables>>=
options="${options} n:m:a:"
usage="${usage} [-n <author name>] [-m <author mail>] [-a <affiliation>]"
name="${NAME:=Author Authorsson}"
mail="${MAIL:=foo@bar.tld}"
affil="${AFFIL:=Independent researcher}"
@ When we process these arguments we simply set the internal variables to the 
given values.
<<arguments handler code>>=
-n)
  shift
  name="$(get_arg "$@")"
  for w in ${name}; do shift; done;;
-m)
  shift
  mail="$(get_arg "$@")"
  for w in ${mail}; do shift; done;;
-a)
  shift
  affil="$(get_arg "$@")"
  for w in ${affil}; do shift; done;;
@ Now we can add the following sed(1) substitutions.
<<run sed(1) on file>>=
sed -i "s/<author>/${name## }/g" ${f}
sed -i "s/<mail>/${mail## }/g" ${f}
sed -i "s/<affil>/${affil## }/g" ${f}
@

We also want to be able to set the title and a \enquote{file-name title} (i.e.\ 
package name) of the document.
The default value for the package name is the same as the current working 
directory.
<<variables>>=
options="${options}t:p:"
usage="${usage} [-t <title>] [-p <package name>]"
package="$(pwd | sed "s/.*\///")"
@ When processing the arguments, we simply set the internal variables to the 
given values.
<<arguments handler code>>=
-t)
  shift
  title="$(get_arg "$@")"
  for w in ${title}; do shift; done;;
-f)
  shift
  package="$(get_arg "$@")"
  for w in ${package}; do shift; done;;
@ Now we can add the following sed(1) substitutions.
<<run sed(1) on file>>=
sed -i "s/<title>/${title## }/g" ${f}
sed -i "s/<package>/${package## }/g" ${f}
@

There is also the location of the submodules, in particular the root directory 
of the [[makefiles]] module~\cite{makefiles}.
<<variables>>=
options="${options}i:"
usage="${usage} [-i <submodule root>]"
submodule_prefix="."
@ Then we update this variable if its argument is given.
<<arguments handler code>>=
-i)
  shift
  submodule_prefix="$(get_arg) "$@""
  for w in ${submodule_prefix}; do shift; done;;
@ Now we can add the following sed(1) substitutions.
<<run sed(1) on file>>=
sed -i "s/<submodule_prefix>/${submodule_prefix## }/g" ${f}
@


\printbibliography{}
\end{document}
